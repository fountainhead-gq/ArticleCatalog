## 除法

### 整数除以整数

进入python交互模式之后，练习下面的运算：
```python
>>> 2 / 5
0.4
>>> 2.0 / 5
0.4
>>> 2 / 5.0
0.4
>>> 2.0 / 5.0
0.4
```
以上四个运算结果都是0.4。(python2.x中,第一个应该是0)

比如：
```python
>>> 5 / 2
2.5
>>> 8 / 2
4.0
```
注意：整数相除得到的商带有小数。

再比如：
```python
>>> 8.0 / 2
4.0
>>> 8 / 2.0
4.0
>>> 8.0 / 2.0
4.0
```
归纳：不管是整数还是浮点数，进行相除，结果是浮点数。

```python
>>> 10.0 / 3
3.3333333333333335
>>> 0.1 + 0.2
0.30000000000000004
>>> 0.1 + 0.1 - 0.2
0.0
>>> 0.1 + 0.1 + 0.1 - 0.3
5.551115123125783e-17
>>> 0.1 + 0.1 + 0.1 - 0.2
0.10000000000000003
```
上面结果的原因在于十进制和二进制的转换上，computer用的是二进制进行计算，她要把十进制的数转化为二进制，然后再计算。但是，在转化中，浮点数转化为二进制，就出问题了。

例如十进制的0.1，转化为二进制是：0.0001100110011001100110011001100110011001100110011...

也就是说，转化为二进制后，不会精确等于十进制的0.1。同时，计算机存储的位数是有限制的，所以，就出现上述现象了。

这种问题不仅仅是python中有，所有支持浮点数运算的编程语言都会遇到，它不是python的bug。

明白了问题原因，怎么解决呢？就python的浮点数运算而言，大多数机器上每次计算误差不超过 2**53 分之一。对于大多数任务这已经足够了，但是要在心中记住这不是十进制算法，每个浮点数计算可能会带来一个新的舍入错误。

一般情况下，只要简单地将最终显示的结果用“四舍五入”到所期望的十进制位数，就会得到期望的最终结果。


### 引用模块解决除法

形式1：import module-name。import后面跟空格，然后是模块名称，例如：import os
形式2：from module1 import module11。module1是一个大模块，里面还有子模块module11，只想用module11，就这么写了。
```python
>>> from __future__ import division
>>> 5 / 2
2.5
>>> 9 / 2
4.5
>>> 9.0 / 2
4.5
>>> 9 / 2.0
4.5
```
注意,引用了一个模块之后，再做除法，就不管什么情况，都得到浮点数的结果。


### 余数

比如：
```python
>>> 5 % 2
1
>>> 6%4
2
>>> 5.0%2
1.0
```


例如函数divmod()
```python
>>> divmod(5,2)  #表示5除以2，返回了商和余数
(2, 1)
>>> divmod(9,2)
(4, 1)
>>> divmod(5.0,2)
(2.0, 1.0)
```

### 四舍五入

动手试试：
```python
>>> round(1.234567,2)
1.23
>>> round(1.234567,3)
1.235
>>> round(10.0/3,4)
3.3333
```

```python
>>> round(1.2345,3)
1.234               #应该是：1.235
>>> round(2.235,2)
2.23                #应该是：2.24
```
这个结果，归根到底还是浮点数中的十进制转化为二进制惹的祸。

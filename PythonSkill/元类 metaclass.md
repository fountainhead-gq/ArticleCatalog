## 元类 metaclass

答案来自[stackoverflow](http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python),以下是部分节选。

![metaclass](http://7xq50z.com1.z0.glb.clouddn.com/metaclass.png)

In most languages, classes are just pieces of code that describe how to produce an object. That's kinda true in Python too:
```python
>>> class ObjectCreator(object):
...       pass
...

>>> my_object = ObjectCreator()
>>> print(my_object)
<__main__.ObjectCreator object at 0x8974f2c>
```
But classes are more than that in Python. Classes are objects too.

Yes, objects.

As soon as you use the keyword class, Python executes it and creates an OBJECT. The instruction
```python
>>> class ObjectCreator(object):
...       pass
```
creates in memory an object with the name "ObjectCreator".

**This object (the class) is itself capable of creating objects (the instances), and this is why it's a class.**

But still, it's an object, and therefore:

you can assign it to a variable
you can copy it
you can add attributes to it
you can pass it as a function parameter
e.g.:
```python
>>> print(ObjectCreator) # you can print a class because it's an object
<class '__main__.ObjectCreator'>
>>> def echo(o):
...       print(o)
...
>>> echo(ObjectCreator) # you can pass a class as a parameter
<class '__main__.ObjectCreator'>
>>> print(hasattr(ObjectCreator, 'new_attribute'))
False
>>> ObjectCreator.new_attribute = 'foo' # you can add attributes to a class
>>> print(hasattr(ObjectCreator, 'new_attribute'))
True
>>> print(ObjectCreator.new_attribute)
foo
>>> ObjectCreatorMirror = ObjectCreator # you can assign a class to a variable
>>> print(ObjectCreatorMirror.new_attribute)
foo
>>> print(ObjectCreatorMirror())
<__main__.ObjectCreator object at 0x8997b4c>
```
### Creating classes dynamically

Since classes are objects, you can create them on the fly, like any object.

First, you can create a class in a function using class:
```python
>>> def choose_class(name):
...     if name == 'foo':
...         class Foo(object):
...             pass
...         return Foo # return the class, not an instance
...     else:
...         class Bar(object):
...             pass
...         return Bar
...     
>>> MyClass = choose_class('foo')
>>> print(MyClass) # the function returns a class, not an instance
<class '__main__.Foo'>
>>> print(MyClass()) # you can create an object from this class
<__main__.Foo object at 0x89c6d4c>
```
But it's not so dynamic, since you still have to write the whole class yourself.

Since classes are objects, they must be generated by something.

When you use the class keyword, Python creates this object automatically. But as with most things in Python, it gives you a way to do it manually.

Remember the function type? The good old function that lets you know what type an object is:
```python
>>> print(type(1))
<type 'int'>
>>> print(type("1"))
<type 'str'>
>>> print(type(ObjectCreator))
<type 'type'>
>>> print(type(ObjectCreator()))
<class '__main__.ObjectCreator'>
```
Well, type has a completely different ability, it can also create classes on the fly. type can take the description of a class as parameters, and return a class.

(I know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backwards compatibility in Python)

type works this way:
```
type(name of the class,
     tuple of the parent class (for inheritance, can be empty),
     dictionary containing attributes names and values)
```
e.g.:
```python
>>> class MyShinyClass(object):
...       pass
```
can be created manually this way:
```python
>>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object
>>> print(MyShinyClass)
<class '__main__.MyShinyClass'>
>>> print(MyShinyClass()) # create an instance with the class
<__main__.MyShinyClass object at 0x8997cec>
```
You'll notice that we use "MyShinyClass" as the name of the class and as the variable to hold the class reference. They can be different, but there is no reason to complicate things.

type accepts a dictionary to define the attributes of the class. So:
```
>>> class Foo(object):
...       bar = True
```
Can be translated to:
```
>>> Foo = type('Foo', (), {'bar':True})
```
And used as a normal class:
```
>>> print(Foo)
<class '__main__.Foo'>
>>> print(Foo.bar)
True
>>> f = Foo()
>>> print(f)
<__main__.Foo object at 0x8a9b84c>
>>> print(f.bar)
True
```
And of course, you can inherit from it, so:
```python
>>>   class FooChild(Foo):
...         pass
```
would be:
```python
>>> FooChild = type('FooChild', (Foo,), {})
>>> print(FooChild)
<class '__main__.FooChild'>
>>> print(FooChild.bar) # bar is inherited from Foo
True
```
Eventually you'll want to add methods to your class. Just define a function with the proper signature and assign it as an attribute.
```python
>>> def echo_bar(self):
...       print(self.bar)
...
>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})
>>> hasattr(Foo, 'echo_bar')
False
>>> hasattr(FooChild, 'echo_bar')
True
>>> my_foo = FooChild()
>>> my_foo.echo_bar()
True
```
And you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.
```python
>>> def echo_bar_more(self):
...       print('yet another method')
...
>>> FooChild.echo_bar_more = echo_bar_more
>>> hasattr(FooChild, 'echo_bar_more')
True
```
You see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.

This is what Python does when you use the keyword class, and it does so by using a `metaclass`.


`Metaclass`是创建class的东西。一个class是用来创建对象的是不是? 但是我们知道，Python中的类也是对象。

`Metaclass`就是用来创建类这些对象的，它们是类的类，你可以形象化地理解为:
```
MyClass = MetaClass()
MyObject = MyClass()
```
你知道， `type`函数可以这样使用:

`MyClass = type('MyClass', (), {})``
这是因为 `type` 实际上是个 `metaclass` , Python使用 `type` 这个元类来创建所有的类。

现在你是不是有疑问了，为什么 `type` 是小写开头的，而不是 Type 呢？既然它是个元类！

我猜，大概是因为和 `str` , `int` 来保持一致吧， `str` 也是一个类，用来创建字符串。

你可以检查下对象的 `__class__` 属性来看看它们的类是谁. Python中万物都是对象:
```python
>>> age = 35
>>> age.__class__
<type 'int'>
>>> name = 'bob'
>>> name.__class__
<type 'str'>
>>> def foo():pass
...
>>> foo.__class__
<type 'function'>
>>> class Bar(object): pass
...
>>> b = Bar()
>>> b.__class__
<class '__main__.Bar'>
```
那么， `__class__` 的 `__class__` 属性又是谁?
```python
>>> a = 1
>>> a.__class__.__class__
<type 'type'>
>>> name = 'bob'
>>> name.__class__.__class__
<type 'type'>
```
所以，元类是用来创建类的。你可以叫元类为类工厂。

### type

`type`的工作方式：
```python
type(name of the class,
     tuple of the parent class (for inheritance, can be empty),
     dictionary containing attributes names and values)
```
`type` 是Python使用的内建元类，当然，Python允许大家建立自己的元类.

### `__metaclass__` 属性

你可以在写一个类的时候加上这个属性 `__metaclass__`
```python
class Foo(object):
  __metaclass__ = something...
  [...]
```
这样的话，Python就会用这个元类(上例中为 something ) 来创建类 `Foo`

我们首先写的是 `class Foo(object)` ,但是Python跑到这里看到这一行时，并没有在内存中建立类 `Foo`

因为Python这么做的：查找它有没有 ``__metaclass__`` 属性，有的话，用指定的类来创建 ``Foo`` ,否则（也就是一般情形下），使用 ``type`` 来创建

最好还是记住上面那句话 :)

当你这么写的时候:
```python
class Foo(Bar):
    pass
```   
Python会这么做:

有 `__metaclass__` 定义吗？ 如果有，在内存中建立一个类的对象。用 `__metaclass__` 指定的类来创建。
如果没有找到这个属性，它会继续在父类 Bar 中找
这样一直向父类找，父类的父类。。。直到 module 级别的才停止。
如果在任何的父类中都找不到，那就用 `type` 创建 Foo
现在一个问题，我们可以给 `__metaclass__` 赋值什么呢?

答案当然是，一个可以创建类的东西。

那么，什么才能创建一个类呢？

### 普通的元类

设计元类的主要目的就是允许我们在类创建的时候动态的修改它，这经常用在API的设计上。

让我们举一个很纯的例子，比如你想要让一个模块中的所有类都共享一些属性，有很多办法可以做到，其中一个就是 在模块中定义一个 `__metaclass__` 属性。

这样，模块中所有的类都会被 `__metaclass__` 创建。

幸运的是 , `__metaclass__` 可以是任何可以被调用的对象。不非要是个class，还可以是个函数。

所以，我们这么做,用一个函数来作为`metaclass`:
```python
# the metaclass will automatically get passed the same argument
# that you usually pass to `type`
def upper_attr(future_class_name, future_class_parents, future_class_attr):
  """
    Return a class object, with the list of its attribute turned
    into uppercase.
  """

  # pick up any attribute that doesn't start with '__'
  attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
  # turn them into uppercase
  uppercase_attr = dict((name.upper(), value) for name, value in attrs)

  # let `type` do the class creation
  return type(future_class_name, future_class_parents, uppercase_attr)

__metaclass__ = upper_attr # this will affect all classes in the module

class Foo(): # global __metaclass__ won't work with "object" though
  # but we can define __metaclass__ here instead to affect only this class
  # and this will work with "object" children
  bar = 'bip'

print hasattr(Foo, 'bar')
# Out: False
print hasattr(Foo, 'BAR')
# Out: True

f = Foo()
print f.BAR
# Out: 'bip'
```
现在我们用一个类来作为一个`metaclass`:
```python
# remember that `type` is actually a class like `str` and `int`
# so you can inherit from it
class UpperAttrMetaclass(type):
    # __new__ is the method called before __init__
    # it's the method that creates the object and returns it
    # while __init__ just initializes the object passed as parameter
    # you rarely use __new__, except when you want to control how the object
    # is created.
    # here the created object is the class, and we want to customize it
    # so we override __new__
    # you can do some stuff in __init__ too if you wish
    # some advanced use involves overriding __call__ as well, but we won't
    # see this
    def __new__(upperattr_metaclass, future_class_name,
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type(future_class_name, future_class_parents, uppercase_attr)
```
但这样并不是很 OOP ， 我们可以直接调用 `type` 函数，并且不覆盖父亲的 `__new__` 方法:
```python
class UpperAttrMetaclass(type):

    def __new__(upperattr_metaclass, future_class_name,
                future_class_parents, future_class_attr):

        attrs = ((name, value) for name, value in future_class_attr.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        # reuse the type.__new__ method
        # this is basic OOP, nothing magic in there
        return type.__new__(upperattr_metaclass, future_class_name,
                            future_class_parents, uppercase_attr)
```
你可能注意到了参数 `upperattr_metaclass` ,没什么特殊的，一个方法总是拿那个实例来作为第一个参数。就像寻常的 `self` 参数。

当然，可以这么写，我上面的例子命名不那么好:)
```python
class UpperAttrMetaclass(type):

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return type.__new__(cls, name, bases, uppercase_attr)
```
我们可以使用 super 函数来让这个例子变得更简洁:
```python
class UpperAttrMetaclass(type):

    def __new__(cls, name, bases, dct):

        attrs = ((name, value) for name, value in dct.items() if not name.startswith('__'))
        uppercase_attr = dict((name.upper(), value) for name, value in attrs)

        return super(UpperAttrMetaclass, cls).__new__(cls, name, bases, uppercase_attr)
```
元类是个简单的魔术，只要:
- 注入类的创建
- 修改类
- 返回修改后的类



### 那么你为什么用类来作为metaclass而不是函数

既然 `__metaclass__` 可以是任何可以被调用的对象，那么你为什么用类作为`metaclass`而不是函数呢？

几个原因:

- 更能清楚的表达意图
- 可以使用OOP, metaclass可以继承，重写父类，甚至使用metaclass，可以使用面向对象的特性。
- 更好的组织代码.



### 应用场景

一个典型例子，Django ORM (译者注,peewee也用metaclass):
```python
class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
```   

但是你这么做:

```python
guy = Person(name='bob', age='35')
print guy.age
```
并不返回一个 `IntegerField` 对象，而是一个 `int`

### 结束语

Python的世界里，万物都是对象。

但是 `type` 是它自己的元类。

99%的情形下你不需要用这个东西。
